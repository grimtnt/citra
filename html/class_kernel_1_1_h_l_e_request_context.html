<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Citra: Kernel::HLERequestContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doc-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Citra
   </div>
   <div id="projectbrief">Nintendo 3DS emulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_kernel_1_1_h_l_e_request_context.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_kernel_1_1_h_l_e_request_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Kernel::HLERequestContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class containing information about an in-flight <a class="el" href="namespace_i_p_c.html">IPC</a> request being handled by an <a class="el" href="namespace_h_l_e.html">HLE</a> service implementation.  
 <a href="class_kernel_1_1_h_l_e_request_context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a591c89620c88839a008694350b6fde61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a591c89620c88839a008694350b6fde61">WakeupCallback</a> = std::function&lt; void(<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_thread.html">Thread</a> &gt; thread, <a class="el" href="class_kernel_1_1_h_l_e_request_context.html">HLERequestContext</a> &amp;context, <a class="el" href="thread_8h.html#a36bd654753f9fb7e2b269831f4e6ad80">ThreadWakeupReason</a> reason)&gt;</td></tr>
<tr class="separator:a591c89620c88839a008694350b6fde61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e496f2a93aacaca77cee975321bfc0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a0e496f2a93aacaca77cee975321bfc0d">HLERequestContext</a> (<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a> &gt; <a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a264994d578f87c2f24b7a8d4c82f2920">session</a>)</td></tr>
<tr class="separator:a0e496f2a93aacaca77cee975321bfc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1250bde3a938f654cc024f876d34506"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#af1250bde3a938f654cc024f876d34506">~HLERequestContext</a> ()</td></tr>
<tr class="separator:af1250bde3a938f654cc024f876d34506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba3a5342a21b6ff24d003dde64e90ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a4ba3a5342a21b6ff24d003dde64e90ac">CommandBuffer</a> ()</td></tr>
<tr class="memdesc:a4ba3a5342a21b6ff24d003dde64e90ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="namespace_i_p_c.html">IPC</a> command buffer for this request.  <a href="#a4ba3a5342a21b6ff24d003dde64e90ac">More...</a><br /></td></tr>
<tr class="separator:a4ba3a5342a21b6ff24d003dde64e90ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f18a9dc986e85fea92d88924f9d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a478f18a9dc986e85fea92d88924f9d39">Session</a> () const</td></tr>
<tr class="memdesc:a478f18a9dc986e85fea92d88924f9d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the session through which this request was made.  <a href="#a478f18a9dc986e85fea92d88924f9d39">More...</a><br /></td></tr>
<tr class="separator:a478f18a9dc986e85fea92d88924f9d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac140c041a57b50c94a05e1db1e31da8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#ac140c041a57b50c94a05e1db1e31da8a">SleepClientThread</a> (<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_thread.html">Thread</a> &gt; thread, const std::string &amp;reason, std::chrono::nanoseconds timeout, <a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a591c89620c88839a008694350b6fde61">WakeupCallback</a> &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac140c041a57b50c94a05e1db1e31da8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the specified guest thread to sleep until the returned event is signaled or until the specified timeout expires.  <a href="#ac140c041a57b50c94a05e1db1e31da8a">More...</a><br /></td></tr>
<tr class="separator:ac140c041a57b50c94a05e1db1e31da8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec71d6cdc7cfb7fb35b92f104d52e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a5ec71d6cdc7cfb7fb35b92f104d52e91">GetIncomingHandle</a> (<a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a> id_from_cmdbuf) const</td></tr>
<tr class="memdesc:a5ec71d6cdc7cfb7fb35b92f104d52e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a object id from the request command buffer into a pointer to an object.  <a href="#a5ec71d6cdc7cfb7fb35b92f104d52e91">More...</a><br /></td></tr>
<tr class="separator:a5ec71d6cdc7cfb7fb35b92f104d52e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc4a0a97d053ea7e21e40875034a223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#abfc4a0a97d053ea7e21e40875034a223">AddOutgoingHandle</a> (<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:abfc4a0a97d053ea7e21e40875034a223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an outgoing object to the response, returning the id which should be used to reference it.  <a href="#abfc4a0a97d053ea7e21e40875034a223">More...</a><br /></td></tr>
<tr class="separator:abfc4a0a97d053ea7e21e40875034a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5fcb8118c0bff4b65b9acade54f66d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a1a5fcb8118c0bff4b65b9acade54f66d">ClearIncomingObjects</a> ()</td></tr>
<tr class="memdesc:a1a5fcb8118c0bff4b65b9acade54f66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards all Objects from the context, invalidating all ids.  <a href="#a1a5fcb8118c0bff4b65b9acade54f66d">More...</a><br /></td></tr>
<tr class="separator:a1a5fcb8118c0bff4b65b9acade54f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad23667b20dc887e51e4167edf9c4d9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a6ad23667b20dc887e51e4167edf9c4d9">GetStaticBuffer</a> (<a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> buffer_id) const</td></tr>
<tr class="memdesc:a6ad23667b20dc887e51e4167edf9c4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the static buffer identified by the input buffer_id.  <a href="#a6ad23667b20dc887e51e4167edf9c4d9">More...</a><br /></td></tr>
<tr class="separator:a6ad23667b20dc887e51e4167edf9c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63708ab799c7024e75531f4793a313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a0e63708ab799c7024e75531f4793a313">AddStaticBuffer</a> (<a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> buffer_id, std::vector&lt; <a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> &gt; data)</td></tr>
<tr class="memdesc:a0e63708ab799c7024e75531f4793a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a static buffer that will be copied to the target process when the request is translated.  <a href="#a0e63708ab799c7024e75531f4793a313">More...</a><br /></td></tr>
<tr class="separator:a0e63708ab799c7024e75531f4793a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff108804e58df2b855ce5407a6ba053d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_kernel_1_1_mapped_buffer.html">MappedBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#aff108804e58df2b855ce5407a6ba053d">GetMappedBuffer</a> (<a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a> id_from_cmdbuf)</td></tr>
<tr class="memdesc:aff108804e58df2b855ce5407a6ba053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a memory interface by the id from the request command buffer.  <a href="#aff108804e58df2b855ce5407a6ba053d">More...</a><br /></td></tr>
<tr class="separator:aff108804e58df2b855ce5407a6ba053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab457386bac198f6fb1f04aa82a26ee1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_result_code.html">ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#ab457386bac198f6fb1f04aa82a26ee1d">PopulateFromIncomingCommandBuffer</a> (const <a class="el" href="swap_8h.html#a18c802bf0535e2e152cf277c504c8bb4">u32_le</a> *src_cmdbuf, <a class="el" href="class_kernel_1_1_process.html">Process</a> &amp;src_process, <a class="el" href="class_kernel_1_1_handle_table.html">HandleTable</a> &amp;src_table)</td></tr>
<tr class="memdesc:ab457386bac198f6fb1f04aa82a26ee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates this context with data from the requesting process/thread.  <a href="#ab457386bac198f6fb1f04aa82a26ee1d">More...</a><br /></td></tr>
<tr class="separator:ab457386bac198f6fb1f04aa82a26ee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe71078ff075222bbbbe41c98a9fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_result_code.html">ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a9ebe71078ff075222bbbbe41c98a9fb9">WriteToOutgoingCommandBuffer</a> (<a class="el" href="swap_8h.html#a18c802bf0535e2e152cf277c504c8bb4">u32_le</a> *dst_cmdbuf, <a class="el" href="class_kernel_1_1_process.html">Process</a> &amp;dst_process, <a class="el" href="class_kernel_1_1_handle_table.html">HandleTable</a> &amp;dst_table) const</td></tr>
<tr class="memdesc:a9ebe71078ff075222bbbbe41c98a9fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from this context back to the requesting process/thread.  <a href="#a9ebe71078ff075222bbbbe41c98a9fb9">More...</a><br /></td></tr>
<tr class="separator:a9ebe71078ff075222bbbbe41c98a9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a38b986007ce1075f7a57e29755be426e"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>, <a class="el" href="namespace_i_p_c.html#ad0a924eda4dbfcd2c2db67efc23c88f1">IPC::COMMAND_BUFFER_LENGTH</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a38b986007ce1075f7a57e29755be426e">cmd_buf</a></td></tr>
<tr class="separator:a38b986007ce1075f7a57e29755be426e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264994d578f87c2f24b7a8d4c82f2920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a264994d578f87c2f24b7a8d4c82f2920">session</a></td></tr>
<tr class="separator:a264994d578f87c2f24b7a8d4c82f2920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbda883255b809b937efc3d6bc74066f"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_object.html">Object</a> &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#abbda883255b809b937efc3d6bc74066f">request_handles</a></td></tr>
<tr class="separator:abbda883255b809b937efc3d6bc74066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e7f85dc938efd18667dc2e549869a2"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; <a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> &gt;, <a class="el" href="namespace_i_p_c.html#a86c73671707e947377f1a8a11f0040c4">IPC::MAX_STATIC_BUFFERS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#aa8e7f85dc938efd18667dc2e549869a2">static_buffers</a></td></tr>
<tr class="separator:aa8e7f85dc938efd18667dc2e549869a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6461d423a811082f46a050c1df6ec9a6"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="class_kernel_1_1_mapped_buffer.html">MappedBuffer</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a6461d423a811082f46a050c1df6ec9a6">request_mapped_buffers</a></td></tr>
<tr class="separator:a6461d423a811082f46a050c1df6ec9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class containing information about an in-flight <a class="el" href="namespace_i_p_c.html">IPC</a> request being handled by an <a class="el" href="namespace_h_l_e.html">HLE</a> service implementation. </p>
<p>Services should avoid using old global APIs (e.g. <a class="el" href="namespace_kernel.html#aee4b2e73a4a4965eaa6b1cd974a7859f" title="Returns a pointer to the command buffer in the current thread&#39;s TLS TODO(Subv): This is not entirely ...">Kernel::GetCommandBuffer()</a>) and when possible use the APIs in this class to service the request.</p>
<h1><a class="el" href="namespace_h_l_e.html">HLE</a> handle protocol </h1>
<p>To avoid needing <a class="el" href="namespace_h_l_e.html">HLE</a> services to keep a separate handle table, or having to directly modify the requester's table, a tweaked protocol is used to receive and send handles in requests. The kernel will decode the incoming handles into object pointers and insert a id in the buffer where the handle would normally be. The service then calls <a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a5ec71d6cdc7cfb7fb35b92f104d52e91" title="Resolves a object id from the request command buffer into a pointer to an object. ...">GetIncomingHandle()</a> with that id to get the pointer to the object. Similarly, instead of inserting a handle into the command buffer, the service calls <a class="el" href="class_kernel_1_1_h_l_e_request_context.html#abfc4a0a97d053ea7e21e40875034a223" title="Adds an outgoing object to the response, returning the id which should be used to reference it...">AddOutgoingHandle()</a> and stores the returned id where the handle would normally go.</p>
<p>The end result is similar to just giving services their own real handle tables, but since these ids are local to a specific context, it avoids requiring services to manage handles for objects across multiple calls and ensuring that unneeded handles are cleaned up.</p>
<h1><a class="el" href="namespace_h_l_e.html">HLE</a> mapped buffer protocol </h1>
<p><a class="el" href="namespace_h_l_e.html">HLE</a> services don't have their own virtual memory space, a tweaked protocol is used to simulate memory mapping. The kernel will wrap the incoming buffers into a memory interface on which <a class="el" href="namespace_h_l_e.html">HLE</a> services can operate, and insert a id in the buffer where the vaddr would normally be. The service then calls GetMappedBuffer with that id to get the memory interface. On response, like real services pushing back the mapped buffer address to unmap it, <a class="el" href="namespace_h_l_e.html">HLE</a> services push back the id of the memory interface and let kernel convert it back to client vaddr. No real unmapping is needed in this case, though. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00155">155</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a591c89620c88839a008694350b6fde61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591c89620c88839a008694350b6fde61">&#9670;&nbsp;</a></span>WakeupCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a591c89620c88839a008694350b6fde61">Kernel::HLERequestContext::WakeupCallback</a> =  std::function&lt;void(<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt;<a class="el" href="class_kernel_1_1_thread.html">Thread</a>&gt; thread, <a class="el" href="class_kernel_1_1_h_l_e_request_context.html">HLERequestContext</a>&amp; context, <a class="el" href="thread_8h.html#a36bd654753f9fb7e2b269831f4e6ad80">ThreadWakeupReason</a> reason)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00174">174</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0e496f2a93aacaca77cee975321bfc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e496f2a93aacaca77cee975321bfc0d">&#9670;&nbsp;</a></span>HLERequestContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Kernel::HLERequestContext::HLERequestContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a> &gt;&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00069">69</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="af1250bde3a938f654cc024f876d34506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1250bde3a938f654cc024f876d34506">&#9670;&nbsp;</a></span>~HLERequestContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kernel::HLERequestContext::~HLERequestContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abfc4a0a97d053ea7e21e40875034a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc4a0a97d053ea7e21e40875034a223">&#9670;&nbsp;</a></span>AddOutgoingHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a> Kernel::HLERequestContext::AddOutgoingHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an outgoing object to the response, returning the id which should be used to reference it. </p>
<p>See the "HLE handle protocol" section in the class documentation for more details. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00081">81</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a0e63708ab799c7024e75531f4793a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e63708ab799c7024e75531f4793a313">&#9670;&nbsp;</a></span>AddStaticBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kernel::HLERequestContext::AddStaticBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a>&#160;</td>
          <td class="paramname"><em>buffer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a static buffer that will be copied to the target process when the request is translated. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00094">94</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a1a5fcb8118c0bff4b65b9acade54f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5fcb8118c0bff4b65b9acade54f66d">&#9670;&nbsp;</a></span>ClearIncomingObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kernel::HLERequestContext::ClearIncomingObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards all Objects from the context, invalidating all ids. </p>
<p>This may be called after reading out all incoming objects, so that the buffer memory can be re-used for outgoing handles, but this is not required. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00086">86</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a4ba3a5342a21b6ff24d003dde64e90ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba3a5342a21b6ff24d003dde64e90ac">&#9670;&nbsp;</a></span>CommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>* Kernel::HLERequestContext::CommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="namespace_i_p_c.html">IPC</a> command buffer for this request. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00161">161</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="a5ec71d6cdc7cfb7fb35b92f104d52e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec71d6cdc7cfb7fb35b92f104d52e91">&#9670;&nbsp;</a></span>GetIncomingHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_object.html">Object</a> &gt; Kernel::HLERequestContext::GetIncomingHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>&#160;</td>
          <td class="paramname"><em>id_from_cmdbuf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves a object id from the request command buffer into a pointer to an object. </p>
<p>See the "HLE handle protocol" section in the class documentation for more details. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00076">76</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="aff108804e58df2b855ce5407a6ba053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff108804e58df2b855ce5407a6ba053d">&#9670;&nbsp;</a></span>GetMappedBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kernel_1_1_mapped_buffer.html">MappedBuffer</a> &amp; Kernel::HLERequestContext::GetMappedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>&#160;</td>
          <td class="paramname"><em>id_from_cmdbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a memory interface by the id from the request command buffer. </p>
<p>See the "HLE mapped buffer
protocol" section in the class documentation for more details. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00226">226</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a6ad23667b20dc887e51e4167edf9c4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad23667b20dc887e51e4167edf9c4d9">&#9670;&nbsp;</a></span>GetStaticBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a> &gt; &amp; Kernel::HLERequestContext::GetStaticBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a>&#160;</td>
          <td class="paramname"><em>buffer_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the static buffer identified by the input buffer_id. </p>
<p>The static buffer <em>must</em> have been created in PopulateFromIncomingCommandBuffer by way of an input StaticBuffer descriptor. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00090">90</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="ab457386bac198f6fb1f04aa82a26ee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab457386bac198f6fb1f04aa82a26ee1d">&#9670;&nbsp;</a></span>PopulateFromIncomingCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_result_code.html">ResultCode</a> Kernel::HLERequestContext::PopulateFromIncomingCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="swap_8h.html#a18c802bf0535e2e152cf277c504c8bb4">u32_le</a> *&#160;</td>
          <td class="paramname"><em>src_cmdbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_kernel_1_1_process.html">Process</a> &amp;&#160;</td>
          <td class="paramname"><em>src_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_kernel_1_1_handle_table.html">HandleTable</a> &amp;&#160;</td>
          <td class="paramname"><em>src_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this context with data from the requesting process/thread. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00098">98</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a478f18a9dc986e85fea92d88924f9d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f18a9dc986e85fea92d88924f9d39">&#9670;&nbsp;</a></span>Session()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt;<a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a>&gt; Kernel::HLERequestContext::Session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the session through which this request was made. </p>
<p>This can be used as a map key to access per-client data on services. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00169">169</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="ac140c041a57b50c94a05e1db1e31da8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac140c041a57b50c94a05e1db1e31da8a">&#9670;&nbsp;</a></span>SleepClientThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_event.html">Event</a> &gt; Kernel::HLERequestContext::SleepClientThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt; <a class="el" href="class_kernel_1_1_thread.html">Thread</a> &gt;&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html#a591c89620c88839a008694350b6fde61">WakeupCallback</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the specified guest thread to sleep until the returned event is signaled or until the specified timeout expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td><a class="el" href="class_kernel_1_1_thread.html">Thread</a> to be put to sleep. </td></tr>
    <tr><td class="paramname">reason</td><td>Reason for pausing the thread, to be used for debugging purposes. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in nanoseconds after which the thread will be awoken and the callback invoked with a Timeout reason. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback to be invoked when the thread is resumed. This callback must write the entire command response once again, regardless of the state of it before this function was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_kernel_1_1_event.html">Event</a> that when signaled will resume the thread and call the callback function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00034">34</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<a id="a9ebe71078ff075222bbbbe41c98a9fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebe71078ff075222bbbbe41c98a9fb9">&#9670;&nbsp;</a></span>WriteToOutgoingCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_result_code.html">ResultCode</a> Kernel::HLERequestContext::WriteToOutgoingCommandBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="swap_8h.html#a18c802bf0535e2e152cf277c504c8bb4">u32_le</a> *&#160;</td>
          <td class="paramname"><em>dst_cmdbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_kernel_1_1_process.html">Process</a> &amp;&#160;</td>
          <td class="paramname"><em>dst_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_kernel_1_1_handle_table.html">HandleTable</a> &amp;&#160;</td>
          <td class="paramname"><em>dst_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data from this context back to the requesting process/thread. </p>

<p class="definition">Definition at line <a class="el" href="hle__ipc_8cpp_source.html#l00164">164</a> of file <a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a38b986007ce1075f7a57e29755be426e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b986007ce1075f7a57e29755be426e">&#9670;&nbsp;</a></span>cmd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="common__types_8h.html#a65cf28726f89e62ccf2f1354bc2716df">u32</a>, <a class="el" href="namespace_i_p_c.html#ad0a924eda4dbfcd2c2db67efc23c88f1">IPC::COMMAND_BUFFER_LENGTH</a>&gt; Kernel::HLERequestContext::cmd_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00236">236</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="abbda883255b809b937efc3d6bc74066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbda883255b809b937efc3d6bc74066f">&#9670;&nbsp;</a></span>request_handles</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt;<a class="el" href="class_kernel_1_1_object.html">Object</a>&gt;, 8&gt; Kernel::HLERequestContext::request_handles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00239">239</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="a6461d423a811082f46a050c1df6ec9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6461d423a811082f46a050c1df6ec9a6">&#9670;&nbsp;</a></span>request_mapped_buffers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="class_kernel_1_1_mapped_buffer.html">MappedBuffer</a>, 8&gt; Kernel::HLERequestContext::request_mapped_buffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00243">243</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="a264994d578f87c2f24b7a8d4c82f2920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264994d578f87c2f24b7a8d4c82f2920">&#9670;&nbsp;</a></span>session</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_kernel.html#afc9bde79933dd23864df0768adeb6cfe">SharedPtr</a>&lt;<a class="el" href="class_kernel_1_1_server_session.html">ServerSession</a>&gt; Kernel::HLERequestContext::session</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00237">237</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<a id="aa8e7f85dc938efd18667dc2e549869a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e7f85dc938efd18667dc2e549869a2">&#9670;&nbsp;</a></span>static_buffers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::vector&lt;<a class="el" href="common__types_8h.html#a254d32383658e016368673396e7afc1b">u8</a>&gt;, <a class="el" href="namespace_i_p_c.html#a86c73671707e947377f1a8a11f0040c4">IPC::MAX_STATIC_BUFFERS</a>&gt; Kernel::HLERequestContext::static_buffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hle__ipc_8h_source.html#l00241">241</a> of file <a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/hle/kernel/<a class="el" href="hle__ipc_8h_source.html">hle_ipc.h</a></li>
<li>src/core/hle/kernel/<a class="el" href="hle__ipc_8cpp_source.html">hle_ipc.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_kernel.html">Kernel</a></li><li class="navelem"><a class="el" href="class_kernel_1_1_h_l_e_request_context.html">HLERequestContext</a></li>
    <li class="footer">Generated on Thu Sep 13 2018 12:49:45 for Citra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
